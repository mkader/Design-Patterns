Design Patterns
================
Design patterns are solutions to general problems that software developers faced during software development. 
These solutions were obtained by trial and error by numerous software developers over quite a substantial period of time.
Design patterns are documented tried and tested solutions for recurring problems in a given context. 

Creational Patterns - It provides way to create objects while hiding the creation logic, rather than instantiating objects directly 
using new operator. This gives program more flexibility in deciding which objects need to be created for a given use case.
--------------------
Abstract Factory  Creates an instance of several families of classes
Builder 	  Separates object construction from its representation
Factory 	  Creates an instance of several derived classes, create object without exposing the creation logic to the client and refer to newly created object using a common interface.
Prototype 	  A fully initialized instance to be copied or cloned
Singleton 	  A class of which only a single instance can exist

Structural Patterns - It concern class and object composition. Concept of inheritance is used to compose interfaces and 
define ways to compose objects to obtain new functionalities.
--------------------
Adapter 	Match interfaces of different classes
Bridge 	  	Separates an object’s interface from its implementation
Composite   	A tree structure of simple and composite objects
Decorator   	Add responsibilities to objects dynamically
Facade 	  	A single class that represents an entire subsystem
Flyweight   	A fine-grained instance used for efficient sharing
Proxy 	  	An object representing another object
Filter		To filter a set of objects using different criteria and chaining them in a decoupled way through logical operations.

Host or Behavioral Patterns - Specifically concerned with communication between objects.
------------------------------
Chain of Responsibility		A way of passing a request between a chain of objects
Command 	 	 	Encapsulate a command request as an object
Interpreter 	  		A way to include language elements in a program
Iterator 	  		Sequentially access the elements of a collection
Mediator 	  Defines simplified communication between classes
Memento 	  Capture and restore an object's internal state
Observer 	  A way of notifying change to a number of classes
State 	  	  Alter an object's behavior when its state changes
Strategy 	  Encapsulates an algorithm inside a class
Template   Defer the exact steps of an algorithm to a subclass
Visitor 	  Defines a new operation to a class without change
Null Object	a null object replaces check of NULL object instance

MVC
Business Delegate
Composite Entity
Data Access Object
Front Controller
Intercepting Filter
Service Layer
Transfer Object

Antipatters
------------
Blob
Coupling

Presentation Logic
-------------------
MVS
MVP
Use Case Controller
--------------------------------------------------------------------------------------------------------------


Patterns come out natually and is completely on-demand. It is not a good practice architecture all design patterns have to 
be implemented in a project.

Design patterns VS Architecture pattern	VS Architecture Style
--------------------------------------------------------------
Design patterns - is actually at the code level (should show some kind pseudo code or logic).
Architecture pattern - it's only block level diagrams (For example Model(M) View(V) Controller(C))
Architecture Style - they are just principles or one liner (for example rest is a architecture style which follows HTTP protocol)

|-------|	|-------|	|----------|
|{Code}	|------>| C ->M |-----> |Principles|
|	|	| C ->V	|	|	   |	        	
|-------|	|-------|	|----------|
Design		Architecture	Architecture
pattern	       	pattern		Style

Below are some examples for each one of them.

Design Pattern		-	Factory , Iterator , Singleton
Architecture Pattern	-	MVC, MVP, MVVM
Architecture Style	-	REST, SOA , IOC

Design patterns are time tested solution for software architecture problems
Design pattern is Object Oriented Programming principles. It helps you to understand OOP problems easily
Design patterns are best practices or time tested practices for object oriented programming problems
Design patterns is solving object oriented programming problems in a much better manner

OOP is a three phase process:-
------------------------------
Template creation - Create classes and write logic(code) for it.
Instantiate - Create entities / objects of these classes and bring them live.
Run - Interact with these objects to achieve the software functionality.

|----------|		Instatnce   
| Class    |-------------------	-------------->(entity) (start performing operations on that object or on that entity)
|(Template)|(1)		use New keyword (2) 	  (3)	
|----------| 

Design patterns are divided in to three categories and they cover these phases as follows:-

OOP Phase				Design pattern category
-------------------------------------------------------------------
Template / Class creation problem	Structural design pattern. (which will address problems regarding class creation, inheritance)
Instantiation problems			Creational design pattern.
Runtime problems			Behavioral design pattern. (when object starts running they use polymorphism, type casting)

Desing Pattern in OOP
------------------------
[Runtime Objects]
   (Behavioral)	
	^
	|
	|
Class	obj	= new	Class();
|		   |
|		   |
V		   V	
(Structural)	 (Creational)
[Static Classes]  [Instancing] 


The Store project
-----------------
	1. Fields -  Customer Name, Phone number , Bill Amount , Bill date and Customer Address.
	2. 2 Types of customer. 
		Lead - not buy anything, just enquiry (Customer name and phone number compulsory)
		Customer - buy things, does a financial transaction. (all fields compulsory)
	3. Provide some validation rules.
	4. Ability to display, add, update and delete customer data, cancelling any modification.
	5. Using SQL Server/ ADO.NET. Later Entity framework. Migration should be seamless without many changes across the system.
	
The technical context diagram
------------------------------
Consume Context		Domain				Persistent Context
------------------------------------------------------------
Windows			Entity				SQL Server
HTML			|				Oracle	
WPF			V				MySQL
Process			Entity->Entity	
----------------------------------------------------------------
UI			Classes & business logic	RDBMS

Three Layer architecture – Managing changes
-------------------------------------------
	Business Logic(Server 2 Tier 2) (CustomerLibrary)	
	^
	|
UI------Domain--DAL-----RDMBS (Server 3 Tier 3)
|		^
v		|
Look & feel	Logic of persistence
-----------		
WinfromCustomer
(Server 1 Tier1)

3 Layer VS 3 Tier - All these three layers are deployed in to separate physical machines.

CustomerLibrary Project (Created old version 2005 projects)
-------------------
Step 1 - mistakes, later it will improve 	
-------------------------------------
namespace CustomerLibrary {
    	public class Customer {
		public string CustomerName { get; set; }
		public string PhoneNumber { get; set; }
		public decimal BillAmount { get; set; }
		public DateTime BillDate { get; set; }
		public string Address { get; set; }
    	}
	public class Lead {
		...the above code
    	}
}

Step 2 - Requirements is  "Lead IS A type of Customer with less validations" & validation
-------------------------------------------------------------------------------------
namespace CustomerLibrary {
    	public class CustomerBase {
		public string CustomerName { get; set; }
		public string PhoneNumber { get; set; }
		public decimal BillAmount { get; set; }
		public DateTime BillDate { get; set; }
		public string Address { get; set; }
		//public void Validate() { } //it would be overridden by the customer and the lead as per there requirement
		//public virtual Validate() { } //change to virutal, it define by the child classes
		public virtual Validate() { 
			throw new Exception("Not Implemented"); //it will be implemented by the child classes
		} 

    	}
    	public class Customer : CustomerBase {
    		//By defining a method as virtual,your child classes, can go and override the validate method
    		public override void Validate() {
    			//base.Validate();
			if (CustomerName.Length == 0) throw new Exception("Customer Name is required");
			if (PhoneNumber.Length == 0) throw new Exception("Phone number is required");
			if (BillAmount > 0) throw new Exception("Bill is required");
			if (BillDate >= DateTime.Now)throw new Exception("Bill date  is not proper");
    		}
    	}
	public class Lead : CustomerBase {
    		public override void Validate() {
    			//base.Validate();
			if (CustomerName.Length == 0) throw new Exception("Customer Name is required");
			if (PhoneNumber.Length == 0) throw new Exception("Phone number is required");
    		}
	} 
}

Step 3 - UI Project - FrmCustomer.cs (for testing)  
--------------------------------------------------
using CustomerLibrary
namespace WinfromCustomer {
	public partial class FrmCustomer : Form {
		private Customer cust  = null;
		private Lead lead = null;
		//Add Gold Customer Here 
		//Combo Box Control
		private void cmbCustomerType_SelectedIndexChanged(...){
			if (cmbCustomerType.Text == "Customer") cust = new Customer();
			else lead = new Lead();
			//Add Gold Customer Here 
		}
		
		//Validate Button
		private void btnValidate_Click(...){
			if (cmbCustomerType.Text == "Customer") cust.Validate();
			else lead.Validate();
			//Add Gold Customer Here 
		}
		
	}
}

SOLID -> S->Single Responsibility principle (SRP)- A class should do only one work at a time and not unrelated things.
-------------------------------------------------
If you see the UI it is supposed to do layouting, visuals, take inputs and so on.
But for now he is creating a “Customer” object which is not his duty.
In other words UI is handling multiple responsibilities which makes the class more complex and unmaintainable in the further times.

The SRP Synonym Separation of concerns(SOC)  
------------------------------------------
One class should do only his concerns and any unwanted concerns should be moved to some other class. 
For example in this case the UI should not be creating “Customer” objects directly.

What is a sign of a good software architecure?
-----------------------------------------------
Whenever a change happens in a software and we have to change at ten places then there is a problem with the software architecture
Suppose if add a new customer type called Gold Customer, all the places, i need to change //Add Gold Customer Here 
When you change at one place you should not be changing at lot of places.

Step 4 - UI minimize this changes from atleast three to one 
-----------------------------------------------------------
private CustomerBase cust  = null; //both of our classes (customer and lead) inherits form the customer base class.
private void cmbCustomerType_SelectedIndexChanged(...){
	//this is polymorphism - wherein the parent class can point toward his child classes on runtime
	//Polymorphism means change as per situation
	//Polymorphism is the fundamental thing to acheive decoupling (like i am se at office, dad at home).
	if (cmbCustomerType.Text == "Customer") cust = new Customer();
	else cust = new Lead();
}

private void btnValidate_Click(...){ cust.Validate(); }

If i add gold customer type, i can add code only "cmbCustomerType_SelectedIndexChanged" 	
	
GOAL - Remove if condition from "cmbCustomerType_SelectedIndexChanged"  and get rid of thid new  keyword
GOAL - if  a new customer type, I should not be making changes UI or any UI

In order to get rid of these classes I need to somehow ensure that the creation of these objects goes into some central class
In other words I need to give this object creation to some other library (Factory) why Factory, because it creates things.

Step 5 - Factory Project 
-------------------------
//This factory class will be responsible for my object creation
using CustomerLibrary
namespace FactoryCustomer {
	public static class Factory {
		public CustomerBase Create(string TypeCust) {
			//But when he returns this strong type it will always return the parent based class
			if (TypeCust == "Customer") return new Customer();
			else return new Lead();
		}
	}
}

using FactoryCustomer
private void cmbCustomerType_SelectedIndexChanged(...){ cust = Factory.Create(cmbCustomerType.Text);}

In my ui I have no reference of the strongly type classes. By using this simple factory pattern
One serious problem with this factory class, "if condition"

Step 6 - Remove if conidtion from FactoryCustomer
-------------------------------------------------
//This centralization of object creation called as Simple Factory pattern [Design_Pattern]
public static class Factory {
	private static Dictionary<string, CustomerBase> custs = new Dictionary<string, CustomerBase>();
	static Factory() {
		//this customer collections is loaded irrespective you wanted or you don't wanted
		custs.Add("Customer", new Customer());
		custs.Add("Lead", new Lead());
	}
	public static CustomerBase Create(string TypeCust) {
		//Getting rid of this if conditions by using polymorphism called as RIP(Replace if with Polymorphism) pattern. [Design_Pattern] 
		return custs[TypeCust]
	}
}

Step 7 - I want that the customer type should be loaded only on demand
----------------------------------------------------------------------
//This centralization of object creation called as Simple Factory pattern [Design_Pattern]
public static class Factory {
	private static Dictionary<string, CustomerBase> custs = null;
	public static CustomerBase Create(string TypeCust) {
		//Lazy Loading [Design_Pattern] means when the objects are needed they are loaded or else they are not loaded
		//The opposite if Lazy Loading can be termed as eager loading
		if (custs.Count == 0) {
			custs = new Dictionary<string, ICustomer>();
			custs.Add("Customer", new Customer());
			custs.Add("Lead", new Lead());
		}
		//Getting rid of this if conditions by using polymorphism called as RIP(Replace if with Polymorphism) pattern. [Design_Pattern] 
		return custs[TypeCust]
	}
}

The UI should be only talking with pure definitions rather than implemented concrete classes. 
Interfaces help you create pure definitions. Your UI will then point to these pure definitions and 
not worry about the implemented classes at the back end.
			|--->Lead
UI--->Abstract----------|--->Customer
			|--->Gold Customer
			
Step 8 - Interface Project
-------------------------
namespace ICustomerInterface {
	public interface ICustomer {
		 string CustomerName { get; set; }
		 string PhoneNumber { get; set; }
		 decimal BillAmount { get; set; }
		 DateTime BillDate { get; set; }
		 string Address { get; set; }
		 void Validate();
	}
}


Step 9 - UI code implemented Interface, Factory
-----------------------------------------------------------
//PIC (“Polymorphism + Interfaces + Centralizing object creation”) Pattern for decoupling [Design_Pattern]
using ICustomerInterface
private ICustomer cust  = null;
private void cmbCustomerType_SelectedIndexChanged(...){ cust = Factory.Create(cmbCustomerType.Text);}

public static class Factory {
	private static Dictionary<string, ICustomer> custs = null;
	public static ICustomer Create(string TypeCust) {
		if (custs.Count == 0) {
			custs = new Dictionary<string, ICustomer>();
			custs.Add("Customer", new Customer());
			custs.Add("Lead", new Lead());
		}
		return custs[TypeCust]
	}
}	


Step 10 - Automating Lazy loading using Lazy Keyword (need to rewrite?)
-----------------------------------------------------
    public static class Factory  {
        public static Lazy<Dictionary<string, CustomerBase>> custs = null;

        static Factory()  {
            custs = new Lazy<Dictionary<string, CustomerBase>>(() => LoadCustomerType());
        }

        private static Dictionary<string, CustomerBase> LoadCustomerType()  {
            Dictionary<string, CustomerBase> c = new Dictionary<string, CustomerBase>();
            c.Add("Customer", new Customer());
            c.Add("Lead", new Lead());
            return c;
        }

        public static ICustomer Create(string CustType)  {
            return custs.Value[CustType];
        }
    }

Step 10:- Implementing cloning (Prototype pattern) [Design_Pattern]	 
---------------------------------------------------
The above factory pattern class has a defect

ICustomer cust = Factory.Create("Customer");
cust.CustomerName = "Mak";
ICustomer custnew = Factory.Create("Customer"); 
//custnew.CustomerName  showing "Mak"

Both are return the same instance, because the factory pattern is pointing to the same instance of the collection.

//Define Clone method
public interface ICustomer{
         ....
         ICustomer Clone(); // Added an extra method clone
}

//Using “MemberwiseClone” function, In order to create a “Clone” .NET object. 
//Customer class who is inheriting will also have the ability to clone objects.
public class CustomerBase : ICustomer {
	// Other codes removed for readability       
	public ICustomer Clone() {
		    return (ICustomer) this.MemberwiseClone();
	}
}

//Factory is calling the clone method after the lookup from the collection. 
//So the same reference of the object will not be sent it will be a fresh new copy of object.
public static class Factory {
	// Other codes are removed for readability purpose
	public static ICustomer Create(int CustomerType) {
		return customers.Value[CustomerType].Clone();
	}
}


Step 11 - Automating Simple Factory using Unity
------------------------------------------------
Using some DI frameworks like unity , ninject , MEF etc, instead of writing the above codes.
Install Unity (Install-Package Unity -Version 2.1.505.2 , .net 4.0)

using Microsoft.Practices.Unity;
public static class Factory {
	//In unity or any DI framework concept of the containers. 
	//These containers are nothing but collections. 
	//“RegisterType” and “ResolveType” methods helps to add and get objects 
	//from the container collection respectively.
	static IUnityContainer cont = null; //private static Dictionary<string, ICustomer> custs = null;

	static Factory() {
	    cont = new UnityContainer();
	    cont.RegisterType<ICustomer, Lead>("Lead");			//c.Add("Customer", new Customer());
	    cont.RegisterType<ICustomer, Customer>("Customer");		//c.Add("Lead", new Lead());
	}

	public static ICustomer Create(string CustType) {
	    return cont.Resolve<ICustomer>(CustType);			//custs.Value[CustType];
	}
}

Step 12 :- Abstract classes – The Half defined thing
-------------------------------------------------------
static Factory() {
    // Other codes are removed for readability purpose
    new CustomerBase(); // it will work without any error
}

Validate method is add later. If someone creates the object of this half defined class, CONFUSION
Avoid the confusion by not allowing the client to create the object of the half defined class i.e. by creating an “ABSTRACT CLASS”.
public abstract class CustomerBase : ICustomer {
	// Other codes removed for readability   
	public abstract void Validate();
}

static Factory() {
    // Other codes are removed for readability purpose
    new CustomerBase(); // it will through error on design time
    //Cannot create an instance of the abstract class or interface 'CustomerLibrary.CustomerBase'
}

Step 13 :- Generic Factory
------------------------------
Factory class its binded with the “Customer” type at this moment. if “Supplier” type, need one more “Create” method. 
So if we have lot of business objects like this we would end up with lot of “Create” method.

public static class Factory {
	public static ICustomer Create(int CustomerType) {
		return cont.Resolve<icustomer>(CustomerType.ToString());
	}
	public static Supplier Create(int Supplier) {
		return cont.Resolve<isupplier>(Supplier.ToString());
	}
}
So rather than binding the “Factory” with a single type how about making it a “GENERIC” class.

public static class Factory<T> {  //public static class Factory<anytype> {
	static IUnityContainer cont = null;
	public static T Create(string CustType) {
	    if (cont == null) {
		cont = new UnityContainer();
		cont.RegisterType<ICustomer, Lead>("Lead");
		cont.RegisterType<ICustomer, Customer>("Customer");
	    }
    		return cont.Resolve<T>(CustType);
	}
}

private void cmbCustomerType_SelectedIndexChanged(object sender, EventArgs e) {
    cust = Factory<ICustomer>.Create(cmbCustomerType.Text);
}

Step 14 :- Strategy Pattern (which helps to select algorithms on runtime) for validation [Design_Pattern]
-------------------------------------------
Later, i want add new validations, so we expect the system to be flexible  or I will rather say DYNAMIC to achieve the same.
At this moment the entity classes are tied up with the validation algorithm. In short:-
	We are not following SRP.
	We are not doing SOC and so
	We need to implement IOC that means we need move the logic of algorithm from the entity classes to some other class.
		
Entity		=>		E   n ti  ty
-------				|          |	
[Validation]			V          V	
				Entity 	   Validation	
				Interface  Interface	
					^  |
					|  V
			              Validation Logic		

new StratergyInterface project  created
--------------------------------------
namespace StratergyInterface {
    public interface IValidationStratergy<T>     {
        void Validate(T obj);
    }
}			              

new Validation project created
------------------------------
using StratergyInterface;
using CustomerInterface;
namespace Validation {
    public class CustomerValidation : IValidationStratergy<ICustomer> {
        public void Validate(ICustomer c) {
            if (c.CustomerName.Length == 0) throw new Exception("Customer Name is required");
            ...
        }
    }

    public class LeadValidation : IValidationStratergy<ICustomer> {
        public void Validate(ICustomer c) {
            if (c.CustomerName.Length == 0) throw new Exception("Customer Name is required");
            ...
        }
    }
}

//we can create any entity and inject any validation in to it.
Factory code changed
--------------------
cont.RegisterType<ICustomer, Lead>("Lead", new InjectionConstructor(new LeadValidation()));
cont.RegisterType<ICustomer, Customer>("Customer", new InjectionConstructor(new CustomerValidation()));

CustomerBase class modified
----------------------------
using CustomerInterface;
using StratergyInterface;

namespace CustomerLibrary {
    public abstract class CustomerBase : ICustomer     {
        ....
        public CustomerBase(IValidationStratergy<ICustomer> _Validate) {
            ValidationType = _Validate;
        }
        public IValidationStratergy<ICustomer> ValidationType {get;set;}
    }

    public class Customer : CustomerBase {
        public Customer(IValidationStratergy<ICustomer> obj) : base(obj) { }

        public override void Validate()  {  ValidationType.Validate(this);  }
    }

    public class Lead : CustomerBase {
        public Lead(IValidationStratergy<ICustomer> obj) : base(obj){ }
        public override void Validate(){ ValidationType.Validate(this); }
    }
}
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

Factory Pattern (Creational Patterns) - Creates an instance of several derived classes.
================
Create object without exposing the creation logic to the client and refer to newly created object using a common interface.

The classes, interfaces and objects in the above UML class diagram are as follows:
Product - An interface for creating the objects.
ConcreteProduct - A a class which implements the Product interface.
Factory - This is a class which implements the factory method to return an instance of a ConcreteProduct.

Example - Demo class will use Factory to get a Shape object. 
It will pass information (CIRCLE / SQUARE) to Factory to get the type of object it needs.

//1.Create Interface(Product)
public interface IShape { void Draw(); }

//2.Create Concreate Class implements Interface(ConcreteProduct )
public class Circle : IShape { public void Draw(){ Console.WriteLine("Drew Cirlce"); } }

public class Square : IShape { public void Draw() {Console.WriteLine("Drew Square");} }

//3.Create a Factory to generate object of concrete class (Factory)
public class Factory {
	public IShape Create(string Shape) {
	    if (Shape == "Circle") return new Circle();
	    if (Shape == "Square") return new Square();
	    return null;
	}
}

//4.Create UI Demo Win Form
public void Demo() {
    Factory f = new Factory();

    IShape c = f.Create("Circle");
    c.Draw();

    IShape s = f.Create("Square");
    s.Draw();
}

Abstract Factory Pattern (Creational Patterns) - Creates an instance of several families of classes
================
It work around a super-factory which creates other factories. This factory is also called as factory of factories.
An interface is responsible for creating a factory of related objects without explicitly specifying their classes. 
Each generated factory can give the objects as per the Factory pattern.

Example - Demo class uses FactoryProducer to get a AbstractFactory object. 
It will pass information (CIRCLE / SQUARE for Shape) to AbstractFactory to get the type of object it needs. 
It also passes information (RED /  BLUE for Color) to AbstractFactory to get the type of object it needs.

//1.Create Shape & Color Interface(Product)
public interface IColor  { void Fill(); }

//2.Create Concreate Class implements Interface(ConcreteProduct )
public class Blue : IColor { public void Fill() { Console.WriteLine("Fill Blue");}}

public class Red : IColor { public void Fill() { Console.WriteLine("Fill Red"); }}

//3.Create an Abstract class to get factories for Color and Shape Objects.
public abstract class AbstractFactory {
	public abstract Factory.IShape ShapeCreate(string Shape);
	public abstract IColor ColorCreate(string Color);
}

//4.Create a Shop Factory & ColorFactory to generate object of concrete class
public class ShapeFactory : AbstractFactory {
	public override Factory.IShape ShapeCreate(string Shape) {
	    if (Shape == "Square") return new Factory.Square();
	    else if (Shape == "Circle") return new Factory.Circle();
	    return null;
	}

	public override IColor ColorCreate(string Color) { return null; }
}

public class ColorFactory : AbstractFactory {
	public override Factory.IShape ShapeCreate(string Shape) { return null; }

	public override IColor ColorCreate(string Color) {
	    if (Color == "Blue") return new Blue();
	    else if (Color == "Red") return new Red();
	    return null;
	}
}

//5. Create a Factory generator/producer class to get factories by passing an information such as Shape or Color
public class FactoryProducer {
	public static AbstractFactory Generator(string Choice) {
	    if (Choice == "Shape") return new ShapeFactory();
	    else if (Choice == "Color") return new ColorFactory();
	    return null;
	}
}

//6.Create UI Demo Win Form
public void Demo() {
    AbstractFactory shapeGen = FactoryProducer.Generator("Shape");
    Factory.IShape c = shapeGen.ShapeCreate("Circle");
    c.Draw();
    Factory.IShape s = shapeGen.ShapeCreate("Square");
    s.Draw();

    AbstractFactory colorGen = FactoryProducer.Generator("Color");
    IColor r = colorGen.ColorCreate("Red");
    r.Fill();
    IColor b = colorGen.ColorCreate("Blue");
    b.Fill();
}

Prototype Pattern (Creational Patterns) - A fully initialized instance to be copied or cloned
===================

Singleton Pattern (Creational Patterns) - A class of which only a single instance can exist
===================
    //multithreaded environment, If 2 threads enter the same time, then two instances of Singleton will be created.
    //not thread safe. Bad Code, Don't Use it     
    public class SingletonSingleThread {
        private static SingletonSingleThread instance= null;// 

        //make the constructor private so that this class cannot be instantiated
        private SingletonSingleThread() { }

        public static SingletonSingleThread Instance {
            get {
                if (instance == null) instance = new SingletonSingleThread();
                return instance;
            }
        }

        public void ShowMessage(){ Console.WriteLine("Singleton Single Thread - Not Thread Safe"); }
    }

    //Simple Thread Safe, multithreading. Slow, only one thread can access Instance() method at a time. 
    public sealed class MultiThreadLocK {
        private static MultiThreadLocK instance = null;
        private static readonly object Instancelock = new object();

        private MultiThreadLocK() { }

        public static MultiThreadLocK Instance {
            get {
                //Double Checking  if (instance == null) { //Dont' Use this method bad code
                lock (Instancelock) {
                    if (instance == null) instance = new MultiThreadLocK();
                }
                return instance;
            }
        }
    }

    //Early instance creation- thread safe withotr locking - Eager Instance
    public class MultiThreadWihoutLocK {
        private static MultiThreadWihoutLocK instance = new MultiThreadWihoutLocK();

        private MultiThreadWihoutLocK() { }

        public static MultiThreadWihoutLocK Instance { get { return instance; } }
    }

    //Lazy Instance
    public class MultiThreadKLazy {
        private static readonly Lazy<MultiThreadKLazy> lazy = new  Lazy<MultiThreadKLazy>(()=> new MultiThreadKLazy());

        private MultiThreadKLazy() { }

        public static MultiThreadKLazy Instance { get { return lazy.Value; } }
    }

MultiThreadLocK.Instance.ShowMessage();
MultiThreadLocK.Instance.ShowMessage();

Even though we avoided multiple instance creation of singleton class by using Double checked locking or Eager instance creation, 
instances can still be created by :
– cloning
– reflection
– Sub-classing singleton class - to avoid 'provide a private constructor'

Avoid Singleton instance creation by cloning ?
	Implement MethodwiseClone()
	Override the clone() method and throw CloneNotSupportedException from it.
	protected object MemberwiseClone() { throw new Exception("Cloning a singleton object is not allowed"); }	 

Avoid Singleton class instance creation through Reflection ?  Throw an exception from constructor if it already has an instance.
	private Singleton() { if (instance != null) throw new Exception("Cannot create singleton instance through reflection"); }

Uses of Singleton Design Pattern : Logger , Cache, LoadBalancing 

Why singleton pattern is considered an Anti-pattern ? 
	Can't easy to handle with unit tests.
	Memory allocated to an Singleton can’t be freed.
Difference between Static class and Singleton Pattern:
	Static class cannot implement an interface where a singleton class can.
	You can clone the object of Singleton but, you can not clone the static class object
	All members of a static class are static but for a Singleton class it is not a requirement.
	Singleton object stores in Heap but, static object stores in stack
	A static class get initialized when it is loaded so it can not be lazily loaded where a singleton class can be lazily loaded.
	
	
Builder Pattern (Creational Patterns) - Separates complex object construction from its representation
===========================================
Builder pattern builds a complex object using simple objects and using a step by step approach. 
A Builder class builds the final object step by step. This builder is independent of other objects.

The classes, interfaces and objects in the above UML class diagram are as follows:
Builder - An interface which is used to define all the steps to create a product
ConcreteBuilder - A class which implements the Builder interface to create complex product.
Product - A class which defines the parts of the complex object which are to be generated by the builder pattern.
Director - A class which is used to construct an object using the Builder interface.

Restaurant Meal - a burger (Veg or Chic) will be packed by a wrapper and a cold drink (coke or pepsi) will be packed in a bottle.

Example - A restaurant where a meal could be a verg or chicken burger and a cold drink. 
A Meal class having List of Item and a MealBuilder to build different types of Meal. Demo will use MealBuilder to build a Meal.

    //Builder Interface
    public interface IFood {
        string Name();

        Double Price();
    }

    //Concrete Builder
    public class Chicken : IFood{
        public Double Price(){ return 50.5; }

        public string Name() { return "Chicken Burger";}
    }

    public class Veg : IFood{
        public Double Price(){ return 25.0; }

        public string Name(){ return "Veg Burger"; }
    }

    public class Drink : IFood{ 
    	public Double Price() { return 12; }

        public string Name(){ return "Water";}
    }

    //Product
    public class Meal {
        private List<IFood> items = new List<IFood>();

        public void AddItem(IFood item) { items.Add(item); }

        public Double TotalCost() {
            Double cost = 0.0f;

            foreach (IFood item in items) { cost += item.Price(); }
            return cost;
        }

        public void ShowItems() {
            foreach (IFood item in items) {
                Console.Write("Item : " + item.Name());
                Console.WriteLine(", Price : " + item.Price());
            }
        }
    }

    //Director
    public class MealBuilder {
        public Meal VegMeal() {
            Meal meal = new Meal();
            meal.AddItem(new Veg());
            meal.AddItem(new Drink());
            return meal;
        }

        public Meal NonVegMeal() {
            Meal meal = new Meal();
            meal.AddItem(new Chicken());
            meal.AddItem(new Drink());
            return meal;
        }
    }

        public static void Demo() {
            MealBuilder mealBuilder = new MealBuilder();

            Meal vegMeal = mealBuilder.VegMeal();
            Console.WriteLine("Veg Meal");
            vegMeal.ShowItems();
            Console.WriteLine("Total Cost: " + vegMeal.TotalCost());

            Meal nonVegMeal = mealBuilder.NonVegMeal();
            Console.WriteLine("\n\nNon-Veg Meal");
            nonVegMeal.ShowItems();
            Console.WriteLine("Total Cost: " + nonVegMeal.TotalCost());

            Console.ReadLine();
        }



Adapter (Structural Patterns) - Match interfaces of different classes. It works as a bridge between two incompatible(independent) interfaces. 
================================
It involves a single class which is responsible to join functionalities of independent or incompatible interfaces. 
Example, a card reader which acts as an adapter between memory card and a laptop. You plugin the memory card into card reader 
and card reader into the laptop so that memory card can be read via laptop.

Example -  AudioPlayer can play mp3 format audio files by default. AdvancedMediaPlayer can play vlc and mp4 format files.
We want to make AudioPlayer to play other formats as well. To attain this, an adapter class MediaAdapter 
which implements the MediaPlayer interface and uses AdvancedMediaPlayer objects to play the required format.

AudioPlayer uses the adapter class MediaAdapter passing it the desired audio type without knowing the actual class 
which can play the desired format. Demo will use AudioPlayer class to play various formats.

//ITarget Interface
public interface IMediaPlayer { void Play(string FileType, string FileName); }

//interface
public interface IAdvancedMediaPlayer {
	void PlayVLC(string FileName);
	void PlayMP4(string FileName);
}

//concrete classes implementing the AdvancedMediaPlayer interface
public class VLCPlayer : IAdvancedMediaPlayer {
	public void PlayVLC(string FileName) { Console.WriteLine("Playing vlc: " + FileName);}
	public void PlayMP4(string FileName) { }
}

public class MP4Player : IAdvancedMediaPlayer {
	public void PlayVLC(string FileName) { }

	public void PlayMP4(string FileName) { Console.WriteLine("Playing mp4: " + FileName); }
}

//Adapater Class
public class MediaAdapter : IMediaPlayer {
	private IAdvancedMediaPlayer advancedMediaPlayer;

	public MediaAdapter(string FileType){
	    if (FileType == "mp4") advancedMediaPlayer = new MP4Player();
	    if (FileType == "vlc") advancedMediaPlayer = new VLCPlayer();
	}

	public void Play(string FileType, string FileName){
    		if (FileType == "mp4") advancedMediaPlayer.PlayMP4(FileName);
		if (FileType == "vlc") advancedMediaPlayer.PlayVLC(FileName);
	}
}

//The 'Adaptee', Concreate Class implementing the IMediaPlayer interface
//AudioPlayer uses the adapter class, passing the audio type,
//without knowing the actual class which can play the desired format.
public class AudioPlayer : IMediaPlayer {
	private MediaAdapter mediaAdapter;
	public void Play(string FileType, string FileName) {
    		if (FileType == "mp3") Console.WriteLine("Playing mp3: " + FileName);
    		else if (FileType == "mp4" || FileType == "vlc") {
			mediaAdapter = new MediaAdapter(FileType);
			mediaAdapter.Play(FileType, FileName);
    		} else {
			Console.WriteLine("Invalid File Type");
    		}
	}
}

public static void Demo() {
    AudioPlayer audioPlayer = new AudioPlayer();

    audioPlayer.Play("mp3", "MP3 File");
    audioPlayer.Play("mp4", "MP4 File");
    audioPlayer.Play("vlc", "VLC File");
    audioPlayer.Play("avi", "AVI File");
}

When to use Adapter Design Pattern:
	Adapter makes things work after they’re designed
	Adapter provides a different interface to its subject
	Adapter is meant to change the interface of an existing object

Decoupling
==========
public class Customer {
	private string name;  //instance variable, can be direcly accessed by an object of type customer
	public void setName(string n){ name =n; } //
	public string getName(){ return name; }
}

Within each of the setters/getters, a programmer could convert from one type to another. 
For example, if name was stored as an array of characters, the setter could accept a string as a parameter 
and convert to an array of characters, which would be stored in the instance variable.

Change to a data type of an instance variable, this could be very easily done, and the getter/setter for that variable would be modified. 

Maintaining objects(cusomter) would not need to rewrite any code for these objects, since the get/set would still behave the same way. 

This is the concept of decoupling: separating implementation from manipulation.


Bridge (Structural Patterns) - 	Separates an object’s interface from its implementation
=============================
Bridge is used when we need to decouple an abstraction from its implementation so that the two can vary independently. 
It decouples implementation class and abstract class by providing a bridge structure between them.

It involves an interface which acts as a bridge which makes the functionality of concrete classes independent from 
interface implementer classes. Both types of classes can be altered structurally without affecting each other.

Example - Shape is an abstract class and will use object of DrawAPI. Demo will use Shape class to draw different colored circle.

//Bridge - interface which acts as a bridge between the abstraction class and implementer classes 
public interface DrawAPI { void DrawCircle(int radius, int x, int y); }

//ImplementationA & ImplementationB - concreate classes
public class RedCircle : DrawAPI { public void DrawCircle(int radius, int x, int y) { Console.WriteLine("Draw Red Circle"); } }

public class GreenCircle : DrawAPI{ public void DrawCircle(int radius, int x, int y) { Console.WriteLine("Draw Green Circle"); }}

//Abstraction - An abstract class and containing members that define an abstract business object and its functionality. 
//It contains a reference to an object of type Bridge.  It can also acts as the base class for other abstractions.
public abstract class Shape {
	protected DrawAPI drawAPI;
	protected Shape(DrawAPI drawAPI) { this.drawAPI = drawAPI; }
	public abstract void Draw();
}

//Redefined Abstraction - a class which inherits from the Abstraction class. It extends the interface defined by Abstraction class.
public class Circle :Shape {
	private int x;
	private int y;
	private int radius;

	//super(java) is equal to base (c#)
	public Circle(int x, int y, int radius, DrawAPI drawAPI) :base(drawAPI){
    		this.x = x;
    		this.y = y;
    		this.radius = radius;
	}
	public override void Draw(){ drawAPI.DrawCircle(radius, x, y);}
}

//Client
public static void Demo() {
    Shape red = new Circle(100, 100, 100, new RedCircle());
    Shape green = new Circle(100, 100, 100, new GreenCircle());

    red.Draw();
    green.Draw();
}

When to use Bridge Design Pattern:
	It is used when you want run-time binding of the implementation,
	It is used when you have a proliferation of classes resulting from a coupled interface and numerous implementations,
	It is used when you want to share an implementation among multiple objects,
	It is used when you need to map orthogonal class hierarchies.


Composite (Structural Patterns) - A tree structure of simple and composite objects
================================
It is used where we need to treat a group of objects in similar way as a single object. It creates a tree structure of group of objects.

Example - A class Employee which acts as composite pattern actor class. Demo will use Employee class to add department level hierarchy 
and print all employees.

public class Employee {
	private string name;
	private string dept;
	private List<Employee> subOrdinates;

	public Employee(string name, string dept) {
    		this.name = name;
    		this.dept = dept;
    		subOrdinates = new List<Employee>();
	} 

	public void Add(Employee e){ subOrdinates.Add(e);}

	public void Remove(Employee e){ subOrdinates.Remove(e);}

	public List<Employee> GetSubOrdinates(){ return subOrdinates; }

	public override string ToString(){ return "Name: " + name + " Dept: "+ dept;}
}

public static void Demo() {
    Employee ceo = new Employee("A", "Head");
    Employee sales= new Employee("B", "Head Sales");
    Employee marketing = new Employee("C", "Head Marketing");
    ceo.Add(sales);
    ceo.Add(marketing);

    Employee clerk1 = new Employee("D", "Marketing");
    Employee clerk2 = new Employee("E", "Marketing");
    marketing.Add(clerk1);
    marketing.Add(clerk2);

    Employee executive = new Employee("F", "Sales");
    sales.Add(executive);

    Console.WriteLine(ceo);
    foreach(var e in ceo.GetSubOrdinates())
    {
	Console.WriteLine("\t"+e);
	foreach (var s in e.GetSubOrdinates())
	{
	    Console.WriteLine("\t\t" + e);
	}
    }
}

Decorator(Structural Patterns)- Add responsibilities to objects dynamically
==================================
It allows a user to add new functionality to an existing object without altering its structure. It acts as a wrapper to existing class.
It creates a decorator class which wraps the original class and provides additional functionality keeping class methods signature intact.

Example - An abstract decorator class ShapeDecorator implementing the Shape interface and having Shape object as its instance variable.
Demo will use RedShapeDecorator to decorate Shape objects.

public abstract class ShapeDecorator: Factory.IShape {
	protected Factory.IShape decoratedShape;

	public ShapeDecorator(Factory.IShape decoratedShape){ this.decoratedShape = decoratedShape; }
	abstract public void Draw();
}

//concreate decorator
public class RedShapeDecorator : ShapeDecorator {
	public RedShapeDecorator(Factory.IShape decoratedShape) : base(decoratedShape) { }

	public override void Draw() {
    		decoratedShape.Draw();
    		SetRedBorder(decoratedShape);
	}

	private void SetRedBorder(Factory.IShape decoratedShape) { Console.WriteLine("Red Border"); }
}

public static void Demo() {
	Factory.IShape c = new Factory.Circle();
	Factory.IShape rc = new RedShapeDecorator(new Factory.Circle());

	c.Draw();
	rc.Draw();

	Console.ReadLine();
}

When to use Decorator Design Pattern:
	It provides an enhanced interface.
	It enhances an object’s responsibilities so it is more transparent to client
	It rely on recursive composition to organize an open-ended number of objects.
	It can be viewed as a degenerate Composite with only one component
	It provide a level of indirection to another object, and the implementations keep a reference to the object to which they forward request


Facade (Structural Patterns) 	  	A single class that represents an entire subsystem
==============================================
It hides the complexities of the system and provides an interface to the client using which the client can access the system. 
It involves a single class which provides simplified methods required by client and delegates calls to methods of existing system classes.

Example - ShapeMaker class uses the concrete classes to delegate user calls to these classes. Demo will use ShapeMaker class to show the results.

public class ShapeMaker {
	private Factory.IShape circle;
	private Factory.IShape square;

	public ShapeMaker() {
	    circle = new Factory.Circle();
	    square = new Factory.Square();
	}

	public void DrawCircle() { circle.Draw(); }

	public void DrawSquare(){ square.Draw();}
}

public static void Demo() {
    ShapeMaker sm = new ShapeMaker();
    sm.DrawCircle();
    sm.DrawSquare();
}

Flyweight(Structural Patterns)   	A fine-grained instance used for efficient sharing
===================================
It is primarily used to reduce the number of objects created and to decrease memory footprint and increase performance. 
It tries to reuse already existing similar kind objects by storing them and creates new object when no matching object is found. 

Example - ShapeFactory has a Dictionary of Triangle having key as color of the Triangle object. 
Whenever a request comes to create a Triangle of particular color to ShapeFactory, it checks the Triangle object in its Dictionary, 
if object of Triangle found, that object is returned otherwise a new object is created, stored in Dictionary for future use, 
and returned to client.
Demo will use ShapeFactory to get a Shape object. It will pass information (red / green / blue/ black / white) to ShapeFactory 
to get the circle of desired color it needs.

public class Triangle : Factory.IShape {
	private string _color;
	public Triangle(string color){ _color = color; }
	public void Draw() { Console.WriteLine(_color +  " : Triangle : Draw()"); }
}
public class ShapeFactory {
	//properties - java is final, c# readonly
	//method - java is final, c# sealed
	private static readonly  Dictionary<string, Factory.IShape> triangle = new Dictionary<string, Factory.IShape>();

	public static Factory.IShape GetTriangle(string color) {
		Factory.IShape t;
	    	triangle.TryGetValue(color, out t);
		if (t == null) {
			t = new Triangle(color);
			triangle.Add(color, t);
			Console.WriteLine(color + " : Creating new Object ");
    		}
	    	return t;
	}
}

private static readonly string[] colors = new string[] { "red", "blue", "green", "white", "black" };
public static void Demo() {
    for (int i = 0; i < 20; i++)
    {
	Triangle t = (Triangle)ShapeFactory.GetTriangle(GetColors());
	t.Draw();
    }
}
public static string GetColors() {
    Random r = new Random();
    string s  =colors[r.Next(0, colors.Length)];
    return s;
}


Proxy(Structural Patterns) 	  	An object representing another object
===================================
Example  - ProxyImage is a a proxy class to reduce memory footprint of RealImage object loading.
Demo will use ProxyImage to get an Image object to load and display as it needs.

In proxy pattern, a class represents functionality of another class. 

public interface IImage { void Display(); }

public class RealImage : IImage {
	private string FileName;

	public RealImage(string FileName) {
    		this.FileName = FileName;
    		LoadFromDisk(FileName);
	}

	public void Display() { Console.WriteLine(FileName + " : Display"); }
	public void LoadFromDisk(string FileName) { Console.WriteLine(FileName + " : Load Disk"); }
}

public class ProxyImage : IImage {
	private RealImage realImage;
	private string fileName;

	public ProxyImage(string FileName) { fileName = FileName; }
	public void Display() {
    		if (realImage == null){ realImage = new RealImage(fileName); }
    		realImage.Display();
	}
}

public static void Demo() {
    IImage i = new ProxyImage("test.jpg");
    //image will  be loaded from disk
    i.Display();
    //image will not be loaded from disk
    i.Display();
    Console.ReadLine();
}

Filter(Structural Patterns)  - It combines multiple criteria to obtain single criteria
==================================
To filter a set of objects using different criteria and chaining them in a decoupled way through logical operations.

Exmple - Demo uses Criteria objects to filter List of Person objects based on various criteria and their combinations.

public class Person {
	public string Name { get; set; }
	public string Gender { get; set; }
	public string Status { get; set; }
}

public interface Criteria { List<Person> MeetCriteria(List<Person> persons); }

public class Male : Criteria {
	public List<Person> MeetCriteria(List<Person> persons) { return persons.Where(p => p.Gender == "Male").ToList();}
}

public class Female : Criteria	{
	public List<Person> MeetCriteria(List<Person> persons) { return persons.Where(p => p.Gender == "Female").ToList(); }
}

public class Single : Criteria {
	public List<Person> MeetCriteria(List<Person> persons) { return persons.Where(p => p.Status == "Single").ToList(); }
}

public class AndCriteria : Criteria {
	public Criteria first { get; set; }
	public Criteria second { get; set; }

	public List<Person> MeetCriteria(List<Person> persons) {
    		return second.MeetCriteria(first.MeetCriteria(persons));
	}
}

public class OrCriteria : Criteria {
	public Criteria first { get; set; }
	public Criteria second { get; set; }

	public List<Person> MeetCriteria(List<Person> persons) {
	    List<Person> fl = first.MeetCriteria(persons);
	    List<Person> sl = second.MeetCriteria(persons);
	    return fl.Union(sl).ToList();
	}
}

public static void Demo(){
    List<Person> persons = new List<Person>();

    persons.Add(new Person() {Name= "Robert", Gender="Male", Status="Single" });
    persons.Add(new Person() {Name = "John", Gender="Male", Status="Married" });
    persons.Add(new Person() { Name = "Mike", Gender = "Male", Status = "Single" });
    persons.Add(new Person() { Name = "Bobby", Gender = "Male", Status = "Single" });
    persons.Add(new Person() { Name = "Laura", Gender = "Female", Status = "Married" });
    persons.Add(new Person(){Name="Diana", Gender="Female", Status="Single" });

    Criteria male = new Male();
    Criteria female = new Female();
    Criteria single = new Single();
    Criteria singleMale = new AndCriteria() {first=single,second=male };
    Criteria singleOrFemale = new OrCriteria() {first= single, second=female};

    Console.WriteLine("Males: ");
    printPersons(male.MeetCriteria(persons));

    Console.WriteLine("Females: ");
    printPersons(female.MeetCriteria(persons));

    Console.WriteLine("singles: ");
    printPersons(single.MeetCriteria(persons));

    Console.WriteLine("Single Males: ");
    printPersons(singleMale.MeetCriteria(persons));

    Console.WriteLine("Single Or Females: ");
    printPersons(singleOrFemale.MeetCriteria(persons));

    Console.ReadLine();
}

public static void printPersons(List<Person> persons){
    foreach(var p in persons) {
	Console.WriteLine("Person : [ Name : " + p.Name + ", Gender : " + p.Gender + ", Status : " + p.Status + " ]");
    }
}


Chain of Responsibility (Host or Behavioral Patterns)-	  A way of passing a request between a chain of objects
===========================
It creates a chain of receiver objects for a request. It decouples sender and receiver of a request based on type of request. 
In this pattern, normally each receiver contains reference to another receiver. 
If one object cannot handle the request then it passes the same to the next receiver and so on.

Example - An abstract class AbstractLogger with a level of logging. Created three types of loggers extending the AbstractLogger. 
Each logger checks the level of message to its level and print accordingly otherwise does not print and pass the message to its next logger.

public abstract class AbstractLogger {
	public static int INFO = 1;
	public static int DEBUG = 2;
	public static int ERROR = 3;

	protected int level;

	//next element in chain or responsibility
	protected AbstractLogger NextLogger;
	public void SetNextLogger(AbstractLogger NextLogger) { this.NextLogger = NextLogger; }

	public void LogMessage(int level, string msg) {
	    if (this.level <= level) Write(msg);
	    if (NextLogger != null) NextLogger.LogMessage(level, msg);
	}

	abstract protected void Write(string msg);
}

public class ConsoleLogger : AbstractLogger {
	public ConsoleLogger(int level) { this.level = level; }
	protected override void Write(string msg) { Console.WriteLine("Standard Console::Logger: " + msg);}
}

public class ErrorLogger : AbstractLogger{
	public ErrorLogger(int level){ this.level = level;}
	protected override void Write(string msg){ Console.WriteLine("Error Console::Logger: " + msg);}
}

public class FileLogger : AbstractLogger{
	public FileLogger(int level){ this.level = level; }
	protected override void Write(string msg){ Console.WriteLine("File::Logger: " + msg); }
}

public static class Client{
	private static AbstractLogger GetChainOfLoggers() {
	    AbstractLogger error = new ErrorLogger(AbstractLogger.ERROR);
	    AbstractLogger debug = new FileLogger(AbstractLogger.DEBUG);
	    AbstractLogger info = new ConsoleLogger(AbstractLogger.INFO);

	    error.SetNextLogger(debug);
	    debug.SetNextLogger(info);

	    return error;
	}

	public static void Demo() {
	    AbstractLogger lc = GetChainOfLoggers();
	    lc.LogMessage(AbstractLogger.INFO, "This is an information");
	    lc.LogMessage(AbstractLogger.DEBUG, "This is an debug information");
	    lc.LogMessage(AbstractLogger.ERROR, "This is an error information");
	    Console.ReadLine();
	}
}


Command (Host or Behavioral Patterns)	  Encapsulate a command request as an object
==============================================
It is a data driven design pattern and falls under behavioral pattern category. 
A request is wrapped under an object as command and passed to invoker object. 
Invoker object looks for the appropriate object which can handle this command and passes the command to the corresponding 
object which executes the command.

Example - Broker object uses command pattern to identify which object will execute which command based on the type of command. 
Demo will use Broker class to demonstrate command pattern.

//which acts as a command
public interface IOrder { void Execute();}

//which acts as a request (Receiver)
public class Stock {
	private string name = "GLE";
	private int quantity = 10;

	public void Buy(){ Console.WriteLine("Stock Bought " + name + " : " + quantity); }

	public void Sell(){ Console.WriteLine("Stock Sold " + name + " : " + quantity); }
}

//which will do actual command processing
public class BuyStock : IOrder {
	public Stock Stock { get; set; }
	public void Execute(){ Stock.Buy();}
}

//which will do actual command processing
public class SellStock : IOrder {
	public Stock Stock { get; set; }
	public void Execute() {     Stock.Sell(); }
}

//Invoker, It can take and place orders.
public class Broker {
	private List<IOrder> orders = new List<IOrder>();

	public void TakeOrder(IOrder s) {     orders.Add(s); }

	public void PlaceOrder() { 
    		foreach(var o in orders) o.Execute();
    		orders.Clear();

	}
}

public static void Demo() {
    Stock s = new Stock();
    IOrder bs = new BuyStock() { Stock= s};
    IOrder ss = new SellStock() { Stock = s };

    Broker b = new Broker();
    b.TakeOrder(bs);
    b.TakeOrder(ss);
    b.PlaceOrder();
}

Interpreter (Host or Behavioral Patterns) - 	  A way to include language elements in a program
=======================================================
It provides a way to evaluate language grammar or expression. 
It involves implementing an expression interface which tells to interpret a particular context. 
It is used in SQL parsing, symbol processing engine etc.

public interface IExpression { bool Interpret(string context);    }

public class TerminalExpression : IExpression {
	public string Data { get; set; }
	public bool Interpret(string context) {     return context.Contains(Data); }
}

public class OrExpression : IExpression {
	public IExpression Exp1 { get; set; }
	public IExpression Exp2 { get; set; }
	public bool Interpret(string context) {     return Exp1.Interpret(context) || Exp2.Interpret(context); }
}

public class AndExpression : IExpression {
	public IExpression Exp1 { get; set; }
	public IExpression Exp2 { get; set; }
	public bool Interpret(string context) {     return Exp1.Interpret(context) && Exp2.Interpret(context); }
}

public static class Client	{
	public static IExpression GetMaleExpression() {
    		IExpression e1 = new TerminalExpression() { Data = "A" };
    		IExpression e2 = new TerminalExpression() { Data = "B" };
    		return new OrExpression() { Exp1 = e1, Exp2 = e2 };
	}

	public static IExpression GetMarriedWomanExpression() {
	    IExpression e1 = new TerminalExpression() { Data = "C" };
	    IExpression e2 = new TerminalExpression() { Data = "1" };
	    return new AndExpression() { Exp1 = e1, Exp2 = e2 };
	}
	
	public static void Demo() 	{
    		IExpression e1 = GetMaleExpression();
    		IExpression e2 = GetMarriedWomanExpression();
	
    		Console.WriteLine("A is male? " + e1.Interpret("A")); //true
    		Console.WriteLine("C is a married women "+e2.Interpret("C 1")); //true

    		Console.ReadLine();
	}
}

Iterator (Host or Behavioral Patterns) 	  Sequentially access the elements of a collection
======================================
It is used to get a way to access the elements of a collection object in sequential manner without know its underlying representation.

Example - Demo will use NamesRepository, a concrete class implementation to print a Names stored as a collection in NamesRepository.

//which narrates navigation method
public interface Iterator {
	bool HasNext();	
	object Next();
}

//which retruns the iterator
public interface Container { Iterator GetIterator(); }

public class NameRepository : Container {
	public static string[] names = new string[] { "A", "I", "B", "Z", "E" };

	public Iterator GetIterator() {     return new NameIterator(); }

	public class NameIterator : Iterator {
	    int index;

	    public bool HasNext()     {
		if (index < names.Length) return true;
		return false;
	    }

    	    public object Next()     {
		if(this.HasNext()) return names[index++];
		return null;
	    }
	}
}

public static void Demo() {
    NameRepository nr = new NameRepository();
    //NameRepository.NameIterator ni = new NameRepository.NameIterator();
    for (Iterator i = nr.GetIterator();i.HasNext();)
    	Console.WriteLine( i.Next());
}


List<string> all = new List<string>() { "you", "me", "everyone" };
foreach(string who in all) Console.WriteLine("who: {0}!", who);

Behind the code
using (var it = all.GetEnumerator())
while (it.MoveNext())
{
    string who = it.Current;
    ...
}

Mediator (Host or Behavioral Patterns) 	  Defines simplified communication between classes
=====================================
It is used to reduce communication complexity between multiple objects or classes. 
It provides a mediator class which normally handles all the communications between different classes and supports easy maintenance of the 
code by loose coupling (decoupling). 

compoents - Order, Payment & Product. Order is check for payment, depending upon the paymnet, it orders the products.
Rather then 3 object communicating with other directly, send the event to mediator, mediator will deceide where to go.
So communication logic is completely inside the mediator, and thus mimimize the complexity of communication. 
if these logic are written inside the componets itself, so compoents are heavily tied up. 
if you want to change one compoent, you have to change other componet.

Example - A chat room where multiple users can send message to chat room and it is the responsibility of chat room 
to show the messages to all users. User objects will use ChatRoom method to share their messages. 
Demo will use User objects to show communication between them.

    public class User     {
        public string  Name { get; set; }

        public void Message(string msg)         {             ChatRoom.SendMessage(this, msg);         }
    }

    public class ChatRoom     {
        public static void SendMessage(User user, string msg)         {
            Console.WriteLine(DateTime.Now + " [" + user.Name+"] : " + msg);
        }
    }

        public static void Demo()         {
            User a = new User() { Name = "A" };
            User b = new User() { Name = "B" };
            a.Message("Hi A is Chatting");
            b.Message("Hi B is Chatting");
        }

Memento(Host or Behavioral Patterns)- Capture and restore an object's internal state.
===============================================
It is used to restore state of an object to a previous state. 

Example - It uses 3 actor classes. Memento contains state of an object to be restored. Originator creates and stores states in Memento objects. 
Caretaker object is responsible to restore object state from Memento. 
Demo will use CareTaker and Originator objects to show restoration of object states.

    public class Memento     {         public string State { get; set; }     }

    public class Originator     {
        public string State { get; set; }
        public Memento Memento { get; set; }
    }

    public class CareTaker     {
        private List<Memento> mementoList = new List<Memento>();
        
        public void Add(Memento state)         {             mementoList.Add(state);         }

        public Memento Get(int index)         {             return mementoList[index];         }
    }

        public static void Demo()         {
            Originator o = new Originator() { State="1"};
            CareTaker ct = new CareTaker();
            o.State = "2";
            ct.Add(o.Memento);

            o.State = "3";
            ct.Add(o.Memento);

            o.State = "4";
            Console.WriteLine("Current State " + o.State);

            o.Memento=ct.Get(0);
            Console.WriteLine("First State " + o.State);

            o.Memento=ct.Get(1);
            Console.WriteLine("Second State " + o.State);
        }

Observer (Host or Behavioral Patterns) 	  A way of notifying change to a number of classes
================================================
It is used when there is one-to-many relationship between objects such as if one object is modified, 
its depenedent objects are to be notified automatically.

It uses three actor classes. Subject, Observer and Client. 
Subject is an object having methods to attach and detach observers to a client object. 
Demo will use Subject and concrete class object to show observer pattern in action.

    public class Subject {
        private List<Observer> observers = new List<Observer>();

        private int state;
        public int State         {
            get { return state; }
            set             {
                state = value;
                NotifyAllObjerver();
            }
        }

        public void Attach(Observer o)         {             observers.Add(o);         }

        public void NotifyAllObjerver()         {
            foreach (Observer o in observers) o.Update();
        }
    }

    public abstract class Observer     {
        protected Subject subject;
        public abstract void Update();
    }

    public class BinaryObserver : Observer     {
        public BinaryObserver(Subject s)         {
            this.subject = s;
            this.subject.Attach(this);
        }

        public override void Update()       {         Console.WriteLine("Binary " + Convert.ToString(subject.State,2));      }
    }

    public class OctalObserver: Observer
    {
        public OctalObserver(Subject s)         { 
        	this.subject = s;
            this.subject.Attach(this);
        }

        public override void Update()         {             Console.WriteLine("Octal " + Convert.ToString(subject.State, 8));         }
    }

    public class HexObserver : Observer     {
        public HexObserver(Subject s)         {
            this.subject = s;
            this.subject.Attach(this);
        }

        public override void Update()         {             Console.WriteLine("Hex " + Convert.ToString(subject.State, 16));         }
    }

        public static void Demo()
        {
            Subject s = new Subject();
            new BinaryObserver(s);
            new OctalObserver(s);
            new HexObserver(s);

            Console.WriteLine("First");
            s.State=15;
            Console.WriteLine("Second");
            s.State = 10;
        }


State (Host or Behavioral Patterns) 	  	  Alter an object's behavior when its state changes
==============================================
In State pattern a class behavior changes based on its state. 
In State pattern, objects which represent various states and a context object whose behavior varies as its state object changes.

Example - Context is a class which carries a State. 
Demo will use Context and state objects to demonstrate change in Context behavior based on type of state it is in.

    public interface State{         void DoAction(Context context);     }

    public class Context     {
        public State State { get; set; }

        public Context()         {             State = null;         }
    }

    public class StartState :State     {
        public void DoAction(Context context)
        {
            Console.WriteLine("Player is in start state");
            context.State = this;
        }

        public override string ToString()         {             return "Start State";         }
    }

    public class StopState : State     {
        public void DoAction(Context context)         {
            Console.WriteLine("Player is in stop state");
            context.State = this;
        }

        public override string ToString()         {             return "Stop State";         }
    }

        public static void Demo()         {
            Context c = new Context();
            StartState sa = new StartState();
            sa.DoAction(c);
            Console.WriteLine(c.State.ToString());
            StopState so = new StopState();
            so.DoAction(c);
            Console.WriteLine(c.State.ToString());
        }
    

Strategy (Host or Behavioral Patterns)	  Encapsulates an algorithm inside a class
==================================================
In Strategy pattern, a class behavior or its algorithm can be changed at run time. 

In Strategy pattern, objects which represent various strategies and a context object whose behavior varies as per its strategy object. 
The strategy object changes the executing algorithm of the context object.

Example - Context is a class which uses a Strategy.
Demo will use Context and strategy objects to demonstrate change in Context behaviour based on strategy it deploys or uses.

    public interface Strategy     {         int DoOperation(int i, int j);     }

    public class OperationAdd : Strategy { public int DoOperation(int i, int j) {  return i + j;    }  }
    public class OperationSub : Strategy { public int DoOperation(int i, int j) {  return i - j;    }  }

    public class Context {
        private Strategy strategy;
        public Context(Strategy strategy){ this.strategy = strategy; }

        public int ExecuteStrategy(int i, int j){ return strategy.DoOperation(i, j);}
    }

        public static void Demo()
        {
            Context c = new Context(new OperationAdd());
            Console.WriteLine( c.ExecuteStrategy(1, 2));
            c = new Context(new OperationSub());
            Console.WriteLine(c.ExecuteStrategy(1, 2));
            Console.Read();
        }
    
Template Method (Host or Behavioral Patterns)   Defer the exact steps of an algorithm to a subclass
============================================================
In Template pattern, an abstract class exposes defined way(s)/template(s) to execute its methods. 
Its subclasses can override the method implementation as per need but the invocation is to be in the same way as defined by an abstract class. This pattern comes under behavior pattern category.

A Game abstract class defining operations with a template method cannot be overridden. 

    public abstract class Game {
        public abstract void Initialize();
        public abstract void Start();
        public abstract void End();

	//public virtual void Play() - virutal can be override. 
        public void Play() { //leave virtual, can't override
            Initialize();
            Start();
            End();
        }
    }

    public class Football :Game {
        public override void Initialize() { Console.WriteLine("Football Game is Initialized");}
        public override void Start(){ Console.WriteLine("Football Game is Starred"); }
        public override void End(){ Console.WriteLine("Football Game is End"); }
    }

    public class Baseball : Game {
        public override void Initialize() { Console.WriteLine("Baseball Game is Initialized"); }
        public override void Start() { Console.WriteLine("Baseball Game is Starred"); }
        public override void End(){ Console.WriteLine("Baseball Game is End"); }
    }

        public static void Demo() {
            Football f = new Football();
            f.Play();

            Baseball b = new Baseball();
            b.Play();
        }


Visitor(Host or Behavioral Patterns) 	  Defines a new operation to a class without change
==========================================================================
In Visitor pattern, a visitor class which changes the executing algorithm of an element class. 
By this way, execution algorithm of element can vary as and when visitor varies. 
As per the pattern, element object has to accept the visitor object so that visitor object handles the operation on the element object.

    public interface ComputerPart{ void Accept(ComputerPartVisitor cpv); }

    public class Keyboard : ComputerPart { public void Accept(ComputerPartVisitor cpv) { cpv.Visit(this); } }
    public class Mouse : ComputerPart { public void Accept(ComputerPartVisitor cpv) { cpv.Visit(this); } }
    public class Monitor : ComputerPart { public void Accept(ComputerPartVisitor cpv) { cpv.Visit(this); } }	
    
    public class Computer : ComputerPart {
        ComputerPart[] parts;

        public Computer(){ parts = new ComputerPart[] { new Mouse(), new Keyboard(), new Monitor() }; }

        public void Accept(ComputerPartVisitor cpv) {
            foreach(var p in parts) p.Accept(cpv);
            cpv.Visit(this);
        }
    }

    public interface ComputerPartVisitor {
        void Visit(Computer c);
        void Visit(Mouse m);
        void Visit(Keyboard k);
        void Visit(Monitor m);
    }

    public class ComputerPartDisplayVisitor : ComputerPartVisitor {
        public void Visit(Computer c){ Console.WriteLine("Display Computer");}
        public void Visit(Mouse c){ Console.WriteLine("Display Mouse");}
        public void Visit(Keyboard c){ Console.WriteLine("Display Keyboard");}
        public void Visit(Monitor c){ Console.WriteLine("Display Monitor");}
    }

        public static void Demo(){
            ComputerPart c = new Computer();
            c.Accept(new ComputerPartDisplayVisitor());
        }

Null Object Pattern (Host or Behavioral Patterns) 	 
==================================================
In Null Object pattern, a null object replaces check of NULL object instance. 
Instead of putting if check for a null value, Null Object reflects a do nothing relationship. 
Such Null object can also be used to provide default behaviour in case data is not available.

In Null Object pattern, An abstract class specifying various operations to be done, concrete classes extending this class 
and a null object class providing do nothing implemention of this class and will be used seemlessly where we need to check null value.

    public abstract class AbstractCustomer {
        protected string name;
        public abstract bool IsNil();
        public abstract string GetName();
    }

    public class RealCustomer : AbstractCustomer {
        public RealCustomer(string name){ this.name = name; }

        public override bool IsNil() { return false; }
        public override string GetName() { return name; }
    }

    public class NullCustomer : AbstractCustomer {
        public override bool IsNil(){  return true; }
        public override string GetName(){ return "Not Available in Customer Database"; }
    }

    public class CustomerFactory {
        public static readonly string[] names = new string[]{"A","B","C"};
        
        public static AbstractCustomer GetCustomer(string name) {
            foreach(var n in names) {
                if (n == name) return new RealCustomer(name);
            }
            return new NullCustomer();
        }
    }

        public static void Demo() {
            AbstractCustomer c1 = CustomerFactory.GetCustomer("A");
            AbstractCustomer c2 = CustomerFactory.GetCustomer("D");
            AbstractCustomer c3 = CustomerFactory.GetCustomer("B");
            AbstractCustomer c4 = CustomerFactory.GetCustomer("e");
            Console.WriteLine(c1.GetName());
            Console.WriteLine(c2.GetName());
            Console.WriteLine(c3.GetName());
            Console.WriteLine(c4.GetName());

        }

MVC - Model-View-Controller Pattern. It is used to separate application's concerns.
==============
Model - Model represents an object or JAVA POJO carrying data. It can also have logic to update controller if its data changes.
View - View represents the visualization of the data that model contains.
Controller - It acts on both model and view. It controls the data flow into model object and updates the view whenever data changes. 
	     It keeps view and model separate.


    public class Student {
        public int ID { get; set; }
        public string Name { get; set; }
    }

    public class StudentView {
        public void Print(int id, string name) {
            Console.WriteLine("Student");
            Console.WriteLine("ID : "+ id);
            Console.WriteLine("Name : "+ name);
        }
    }

    public class StudentController {
        private Student model;
        private StudentView view;

        public StudentController(Student model, StudentView view) {
            this.model = model;
            this.view = view;
        }

        public void SetName(string name) { model.Name = name; }

        public string GetName() { return model.Name; }

        public void SetID(int id){ model.ID = id; }

        public int GetID() { return model.ID; }

        public void UpdateView() { view.Print(model.ID, model.Name); }
    }

        public static void Demo() {
            //fetch student record based on his roll no from the database
            Student s = new Student() { Name = "A", ID = 1 };

            //Create a view : to write student details on console
            StudentView v = new StudentView();

            StudentController sc = new StudentController(s, v);
            sc.UpdateView();
            
            //update model
            sc.SetName("B");
            sc.UpdateView();
        }

When Prototype pattern is to be used?
This pattern is used when creation of object directly is costly. For example, an object is to be created after a costly database operation. We can cache the object, returns its clone on next request and update the database as and when needed thus reducing database calls.

Integer class is an example of Decorator pattern. - Wrapper classes like Integer, Boolean uses Decorator pattern.


Which of the following pattern is used when we need to decouple an abstraction from its implementation so that the two can vary independently? Adapter

